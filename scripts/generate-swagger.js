#!/usr/bin/env node

/**
 * ELEVARE - Auto Generate Swagger Documentation
 * Generates basic Swagger/OpenAPI documentation structure
 */

const fs = require('fs');
const path = require('path');

console.log('=== ELEVARE SWAGGER GENERATOR ===');
console.log('Gerando documentação Swagger...\n');

// Find all controller files
function findControllers(dir, fileList = []) {
  const files = fs.readdirSync(dir);
  
  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory() && !file.includes('node_modules') && !file.includes('dist')) {
      findControllers(filePath, fileList);
    } else if (file.endsWith('.controller.ts')) {
      fileList.push(filePath);
    }
  });
  
  return fileList;
}

// Parse controller for routes
function parseController(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  
  // Extract controller name and base path
  const controllerMatch = content.match(/@Controller\(['"]([^'"]*)['"]\)/);
  const classMatch = content.match(/export\s+class\s+(\w+Controller)/);
  
  if (!classMatch) return null;
  
  const controllerName = classMatch[1];
  const basePath = controllerMatch ? controllerMatch[1] : '';
  
  // Extract routes
  const routes = [];
  const methodRegex = /@(Get|Post|Put|Delete|Patch)\(['"]?([^'")\n]*)?['"]?\)[^{]*\n\s*(?:async\s+)?(\w+)/g;
  let match;
  
  while ((match = methodRegex.exec(content)) !== null) {
    const method = match[1].toUpperCase();
    const subPath = match[2] || '';
    const functionName = match[3];
    
    routes.push({
      method,
      path: `/${basePath}${subPath ? '/' + subPath : ''}`.replace(/\/+/g, '/'),
      functionName,
      controllerName
    });
  }
  
  return { controllerName, basePath, routes, filePath };
}

// Generate Swagger JSON documentation
function generateSwaggerDoc(controllers) {
  const packageJsonPath = path.join(process.cwd(), 'package.json');
  let version = '1.0.0';
  let name = 'API';
  
  if (fs.existsSync(packageJsonPath)) {
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
    version = packageJson.version || version;
    name = packageJson.name || name;
  }
  
  const swagger = {
    openapi: '3.0.0',
    info: {
      title: `${name} API Documentation`,
      description: 'API documentation auto-generated by ELEVARE SUPER-AGENT',
      version: version,
      contact: {
        name: 'API Support',
        email: 'support@example.com'
      }
    },
    servers: [
      {
        url: 'http://localhost:3000',
        description: 'Development server'
      },
      {
        url: 'https://api.production.com',
        description: 'Production server'
      }
    ],
    tags: [],
    paths: {}
  };
  
  // Group routes by controller
  const tags = new Set();
  
  controllers.forEach(controller => {
    if (!controller) return;
    
    const tag = controller.controllerName.replace('Controller', '');
    tags.add(tag);
    
    controller.routes.forEach(route => {
      if (!swagger.paths[route.path]) {
        swagger.paths[route.path] = {};
      }
      
      swagger.paths[route.path][route.method.toLowerCase()] = {
        tags: [tag],
        summary: `${route.method} ${route.path}`,
        description: `Endpoint managed by ${route.controllerName}.${route.functionName}`,
        operationId: route.functionName,
        responses: {
          '200': {
            description: 'Successful response',
            content: {
              'application/json': {
                schema: {
                  type: 'object',
                  properties: {
                    message: {
                      type: 'string',
                      example: 'Success'
                    }
                  }
                }
              }
            }
          },
          '400': {
            description: 'Bad request'
          },
          '401': {
            description: 'Unauthorized'
          },
          '500': {
            description: 'Internal server error'
          }
        }
      };
      
      // Add request body for POST, PUT, PATCH
      if (['POST', 'PUT', 'PATCH'].includes(route.method)) {
        swagger.paths[route.path][route.method.toLowerCase()].requestBody = {
          description: 'Request payload',
          required: true,
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  example: {
                    type: 'string',
                    description: 'Example field'
                  }
                }
              }
            }
          }
        };
      }
    });
  });
  
  // Add tags
  swagger.tags = Array.from(tags).map(tag => ({
    name: tag,
    description: `${tag} operations`
  }));
  
  return swagger;
}

// Generate Swagger markdown documentation
function generateSwaggerMarkdown(controllers) {
  let markdown = '# API Documentation\n\n';
  markdown += 'Auto-generated by ELEVARE SUPER-AGENT\n\n';
  markdown += `Generated at: ${new Date().toISOString()}\n\n`;
  
  markdown += '## Controllers\n\n';
  
  controllers.forEach(controller => {
    if (!controller || controller.routes.length === 0) return;
    
    markdown += `### ${controller.controllerName}\n\n`;
    markdown += `Base path: \`/${controller.basePath}\`\n\n`;
    
    markdown += '| Method | Path | Handler |\n';
    markdown += '|--------|------|----------|\n';
    
    controller.routes.forEach(route => {
      markdown += `| ${route.method} | ${route.path} | ${route.functionName} |\n`;
    });
    
    markdown += '\n';
  });
  
  return markdown;
}

try {
  const srcPath = path.join(process.cwd(), 'src');
  
  if (!fs.existsSync(srcPath)) {
    console.log('Diretório src/ não encontrado. Abortando...');
    process.exit(0);
  }
  
  // Find and parse all controllers
  const controllerFiles = findControllers(srcPath);
  console.log(`Encontrados ${controllerFiles.length} controllers\n`);
  
  const controllers = controllerFiles.map(parseController).filter(c => c && c.routes.length > 0);
  
  let totalRoutes = 0;
  controllers.forEach(c => {
    console.log(`✓ ${c.controllerName}: ${c.routes.length} rotas`);
    totalRoutes += c.routes.length;
  });
  
  // Create docs directory
  const docsDir = path.join(process.cwd(), 'src', 'docs');
  if (!fs.existsSync(docsDir)) {
    fs.mkdirSync(docsDir, { recursive: true });
  }
  
  // Generate Swagger JSON
  const swaggerDoc = generateSwaggerDoc(controllers);
  const swaggerPath = path.join(docsDir, 'swagger.json');
  fs.writeFileSync(swaggerPath, JSON.stringify(swaggerDoc, null, 2));
  console.log(`\n✓ Swagger JSON gerado: ${swaggerPath}`);
  
  // Generate Markdown documentation
  const markdownDoc = generateSwaggerMarkdown(controllers);
  const markdownPath = path.join(docsDir, 'API.md');
  fs.writeFileSync(markdownPath, markdownDoc);
  console.log(`✓ Documentação Markdown gerada: ${markdownPath}`);
  
  console.log(`\n=== RESUMO ===`);
  console.log(`Controllers encontrados: ${controllers.length}`);
  console.log(`Total de rotas: ${totalRoutes}`);
  console.log(`Arquivos gerados: 2`);
  console.log('\n=== FIM SWAGGER GENERATOR ===');
  
} catch (error) {
  console.error('Erro ao gerar documentação Swagger:', error.message);
  process.exit(0); // Don't fail the workflow
}
