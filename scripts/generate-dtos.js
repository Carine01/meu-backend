#!/usr/bin/env node

/**
 * ELEVARE - Auto Generate DTOs Script
 * Generates basic DTO scaffolding for entities without DTOs
 */

const fs = require('fs');
const path = require('path');

console.log('=== ELEVARE DTO GENERATOR ===');
console.log('Gerando DTOs básicos...\n');

// Find all entity files
function findEntityFiles(dir, fileList = []) {
  const files = fs.readdirSync(dir);
  
  files.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    
    if (stat.isDirectory() && !file.includes('node_modules') && !file.includes('dist')) {
      findEntityFiles(filePath, fileList);
    } else if (file.endsWith('.entity.ts')) {
      fileList.push(filePath);
    }
  });
  
  return fileList;
}

// Extract entity name and properties from entity file
function parseEntity(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const entityNameMatch = content.match(/export\s+class\s+(\w+)/);
  
  if (!entityNameMatch) return null;
  
  const entityName = entityNameMatch[1];
  const properties = [];
  
  // Extract properties with @Column decorator
  const columnRegex = /@Column\([^)]*\)\s+(\w+)(!|\?)?:\s*([^;]+);/g;
  let match;
  
  while ((match = columnRegex.exec(content)) !== null) {
    const propName = match[1];
    const propType = match[3].trim();
    
    // Skip auto-generated fields
    if (!['createdAt', 'updatedAt', 'id'].includes(propName)) {
      properties.push({ name: propName, type: propType });
    }
  }
  
  return { entityName, properties, filePath };
}

// Get appropriate validation decorator based on type
function getValidationDecorator(type) {
  const normalizedType = type.toLowerCase().trim();
  
  if (normalizedType === 'number') {
    return '@IsNumber()';
  } else if (normalizedType === 'boolean') {
    return '@IsBoolean()';
  } else if (normalizedType === 'date') {
    return '@IsDateString()';
  } else if (normalizedType.includes('[]') || normalizedType.includes('array')) {
    return '@IsArray()';
  } else if (normalizedType === 'object' || normalizedType.includes('{')) {
    return '@IsObject()';
  } else {
    return '@IsString()';
  }
}

// Get required imports based on used decorators
function getRequiredImports(properties) {
  const decorators = new Set(['IsNotEmpty', 'IsOptional']);
  
  properties.forEach(prop => {
    const decorator = getValidationDecorator(prop.type);
    const decoratorName = decorator.replace('@', '').replace('()', '');
    decorators.add(decoratorName);
  });
  
  return Array.from(decorators).sort().join(', ');
}

// Generate DTO content
function generateDTO(entity) {
  const dtoName = `Create${entity.entityName}Dto`;
  const imports = getRequiredImports(entity.properties);
  
  let content = `import { ${imports} } from 'class-validator';\n\n`;
  content += `/**\n`;
  content += ` * DTO for creating ${entity.entityName}\n`;
  content += ` * Auto-generated by ELEVARE DTO Generator\n`;
  content += ` */\n`;
  content += `export class ${dtoName} {\n`;
  
  entity.properties.forEach(prop => {
    const validator = getValidationDecorator(prop.type);
    content += `  @IsNotEmpty()\n`;
    content += `  ${validator}\n`;
    content += `  ${prop.name}!: ${prop.type};\n\n`;
  });
  
  content += `}\n`;
  
  return { dtoName, content };
}

try {
  const srcPath = path.join(process.cwd(), 'src');
  
  if (!fs.existsSync(srcPath)) {
    console.log('Diretório src/ não encontrado. Abortando...');
    process.exit(0);
  }
  
  const entityFiles = findEntityFiles(srcPath);
  console.log(`Encontradas ${entityFiles.length} entidades\n`);
  
  let generatedCount = 0;
  
  entityFiles.forEach(entityFile => {
    const entity = parseEntity(entityFile);
    
    if (!entity || entity.properties.length === 0) {
      console.log(`⊘ Pulando ${entityFile} - sem propriedades válidas`);
      return;
    }
    
    // Check if DTO already exists
    const dtoDir = path.dirname(entityFile).replace('/entities', '/dto');
    const dtoFileName = `create-${entity.entityName.toLowerCase()}.dto.ts`;
    const dtoPath = path.join(dtoDir, dtoFileName);
    
    if (fs.existsSync(dtoPath)) {
      console.log(`⊘ DTO já existe: ${dtoPath}`);
      return;
    }
    
    // Create DTO directory if it doesn't exist
    if (!fs.existsSync(dtoDir)) {
      fs.mkdirSync(dtoDir, { recursive: true });
    }
    
    // Generate and write DTO
    const dto = generateDTO(entity);
    fs.writeFileSync(dtoPath, dto.content);
    
    console.log(`✓ Criado: ${dtoPath}`);
    generatedCount++;
  });
  
  console.log(`\n=== RESUMO ===`);
  console.log(`Total de entidades: ${entityFiles.length}`);
  console.log(`DTOs gerados: ${generatedCount}`);
  console.log(`DTOs já existentes: ${entityFiles.length - generatedCount}`);
  console.log('\n=== FIM DTO GENERATOR ===');
  
} catch (error) {
  console.error('Erro ao gerar DTOs:', error.message);
  process.exit(0); // Don't fail the workflow
}
